<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithms | jtshong</title>
<meta name=keywords content><meta name=description content="Easy
Linear Search
This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.
def linear_search(arr, x):
   for i in range(len(arr)):
      if arr[i] == x:
         return i
   return -1
Binary Search
A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space."><meta name=author content="Scott Hong"><link rel=canonical href=http://localhost:1313/projects/algorithms/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon.ico><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/projects/algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/projects/algorithms/"><meta property="og:site_name" content="jtshong"><meta property="og:title" content="Algorithms"><meta property="og:description" content="Easy Linear Search This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.
def linear_search(arr, x): for i in range(len(arr)): if arr[i] == x: return i return -1 Binary Search A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2024-12-24T17:06:45-05:00"><meta property="article:modified_time" content="2024-12-24T17:06:45-05:00"><meta property="og:image" content="http://localhost:1313/opengraph.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/opengraph.webp"><meta name=twitter:title content="Algorithms"><meta name=twitter:description content="Easy
Linear Search
This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.
def linear_search(arr, x):
   for i in range(len(arr)):
      if arr[i] == x:
         return i
   return -1
Binary Search
A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"http://localhost:1313/projects/"},{"@type":"ListItem","position":2,"name":"Algorithms","item":"http://localhost:1313/projects/algorithms/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Algorithms","name":"Algorithms","description":"Easy Linear Search This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.\ndef linear_search(arr, x): for i in range(len(arr)): if arr[i] == x: return i return -1 Binary Search A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space.\n","keywords":[],"articleBody":"Easy Linear Search This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.\ndef linear_search(arr, x): for i in range(len(arr)): if arr[i] == x: return i return -1 Binary Search A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space.\ndef binary_search(arr, low, high, x): if high \u003e= low: mid = (high + low) // 2 if arr[mid] == x: return mid elif arr[mid] \u003e x: return binary_search(arr, low, mid - 1, x) else: return binary_search(arr, mid + 1, high, x) else: return -1 Bubble Sort A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.\ndef bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] \u003e arr[j + 1] : arr[j], arr[j + 1] = arr[j + 1], arr[j] Selection Sort This sorting algorithm divides the list into a sorted and an unsorted region. It repeatedly selects the smallest (or largest, depending on the ordering) element from the unsorted region and moves it to the sorted region.\ndef selection_sort(arr): for i in range(len(arr)): min_idx = i for j in range(i+1, len(arr)): if arr[min_idx] \u003e arr[j]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] Medium Insertion Sort This sorting algorithm builds a sorted list one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.\ndef insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i-1 while j \u003e=0 and key \u003c arr[j] : arr[j+1] = arr[j] j -= 1 arr[j+1] = key Quick Sort This is a divide-and-conquer sorting algorithm. It works by selecting a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.\ndef partition(arr, low, high): i = (low-1) pivot = arr[high] for j in range(low, high): if arr[j] \u003c= pivot: i = i+1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return (i+1) def quick_sort(arr, low, high): if len(arr) == 1: return arr if low \u003c high: pi = partition(arr, low, high) quick_sort(arr, low, pi-1) quick_sort(arr, pi+1, high) Merge Sort Another divide-and-conquer sorting algorithm that involves splitting the array into two halves, sorting them, and then merging them.\ndef merge_sort(arr): if len(arr) \u003e 1: mid = len(arr)//2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i \u003c len(L) and j \u003c len(R): if L[i] \u003c R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i \u003c len(L): arr[k] = L[i] i += 1 k += 1 while j \u003c len(R): arr[k] = R[j] j += 1 k += 1 Depth-First Search (DFS) A common graph traversal algorithm. It explores as far as possible along each branch before backtracking.\ndef DFS(graph, v, visited): visited[v] = True print(v, end = ' ') for i in graph[v]: if visited[i] == False: DFS(graph, i, visited) Breadth-First Search (BFS) Another common graph traversal algorithm. It visits all the vertices of a graph at the same “level” before going to the next level.\nfrom collections import deque def BFS(graph, root): visited = set() queue = deque([root]) visited.add(root) while queue: vertex = queue.popleft() print(str(vertex) + \" \", end=\"\") for neighbour in graph[vertex]: if neighbour not in visited: queue.append(neighbour) visited.add(neighbour) Hard Heap Sort This comparison-based sorting algorithm transforms the input data structure into a binary heap data structure. It then uses the heap pop operation to obtain the elements in sorted order.\ndef heapify(arr, n, i): largest = i l = 2 * i + 1 r = 2 * i + 2 if l \u003c n and arr[i] \u003c arr[l]: largest = l if r \u003c n and arr[largest] \u003c arr[r]: largest = r if largest != i: arr[i],arr[largest] = arr[largest],arr[i] heapify(arr, n, largest) def heapSort(arr): n = len(arr) for i in range(n//2 - 1, -1, -1): heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) Dijkstra’s Algorithm This algorithm is used to find the shortest path between nodes in a graph. It works for both directed and undirected graphs.\nimport heapq def dijkstra(graph, start_vertex): D = {v: float('inf') for v in graph} D[start_vertex] = 0 queue = [(0, start_vertex)] while queue: d, v = heapq.heappop(queue) if d != D[v]: continue for neighbour, length in graph[v].items(): old_distance = D[neighbour] new_distance = D[v] + length if new_distance \u003c old_distance: D[neighbour] = new_distance heapq.heappush(queue, (new_distance, neighbour)) return D Bellman-Ford Algorithm This algorithm computes shortest paths in a weighted graph where some of the edge weights may be negative.\ndef bellman_ford(graph, start_vertex): distance, predecessor = dict(), dict() for node in graph: distance[node], predecessor[node] = float('inf'), None distance[start_vertex] = 0 for _ in range(len(graph) - 1): for node in graph: for neighbour in graph[node]: if distance[neighbour] \u003e distance[node] + graph[node][neighbour]: distance[neighbour], predecessor[neighbour] = distance[node] + graph[node][neighbour], node return distance, predecessor Floyd-Warshall Algorithm This is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.\ndef floyd_warshall(graph): distance = dict() for node in graph: distance[node] = dict() for neighbour in graph: distance[node][neighbour] = graph[node][neighbour] for intermediate_node in graph: for start_node in graph: for end_node in graph: direct = distance[start_node][end_node] via_i = distance[start_node][intermediate_node] + distance[intermediate_node][end_node] if direct \u003e via_i: distance[start_node][end_node] = via_i return distance Binary Search Tree A Binary Search Tree (BST) is a tree in which all the nodes follow the below property: the left sub-tree of a node has a key less than its parent node’s key, while the right sub-tree of a node has a key greater than to its parent node’s key.\nclass Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return Node(key) else: if root.val \u003c key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def inorder(root): if root: inorder(root.left) print(root.val), inorder(root.right) Knapsack Problem Algorithms The knapsack problem is an optimization problem used to illustrate both problem-solving and computational complexity. There are various algorithms to solve it, including brute force, greedy, and dynamic programming.\ndef knapSack(W, wt, val, n): K = [[0 for w in range(W+1)] for i in range(n+1)] for i in range(n+1): for w in range(W+1): if i == 0 or w == 0: K[i][w] = 0 elif wt[i-1] \u003c= w: K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]) else: K[i][w] = K[i-1][w] return K[n][W] # Test the function with a problem instance val = [60, 100, 120] wt = [10, 20, 30] W = 50 n = len(val) print(knapSack(W, wt, val, n)) # Outputs 220 In this example, W is the maximum weight the knapsack can hold, wt is the list of weights of the items, val is the list of values of the items, and n is the number of items.\nThis function works by building up a 2D array K[][] where each element K[i][w] stores the maximum value that can be achieved with i items and a maximum weight of w. For each item, it considers if it’s optimal to include the item or not by comparing the maximum value achieved by including the item (val[i-1] + K[i-1][w-wt[i-1]]) and the maximum value achieved by excluding the item (K[i-1][w]), and takes the maximum of these two values.\nTravelling Salesman Problem Algorithms The travelling salesman problem is a classic algorithmic problem focused on optimization. It focuses on optimization. In this problem, a salesman is given a list of cities, and must determine the shortest route that allows him to visit each city once and return to his original location.\nfrom sys import maxsize from itertools import permutations V = 4 def travellingSalesmanProblem(graph, s): vertex = [] for i in range(V): if i != s: vertex.append(i) min_path = maxsize next_permutation=permutations(vertex) for i in next_permutation: current_pathweight = 0 k = s for j in i: current_pathweight += graph[k][j] k = j current_pathweight += graph[k][s] min_path = min(min_path, current_pathweight) return min_path if __name__ == \"__main__\": graph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]] s = 0 print(travellingSalesmanProblem(graph, s)) In this code, s is the starting point, and graph[i][j] is the length of the path from i to j. This code iterates over all permutations of the vertices (excluding the starting vertex s) to find the minimum weight cycle.\nPlease note that this code has a time complexity of O(n!), where n is the number of vertices, because it tries all possible permutations. Therefore, it can be very slow for larger graphs. There are more efficient algorithms to solve the TSP for special cases (like when the graph satisfies the triangle inequality), and there are also approximation algorithms for the general case.\nDynamic Programing Dynamic programming (DP) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions - ideally, using a memory-based data structure.\nThe idea is to save computation time by avoiding needless recomputation of identical subproblems - this is also known as “memoization”. The technique was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.\nThe key concept here is the “principle of optimality,” which is the idea that the optimal solution to a problem can be constructed from the optimal solutions of its subproblems.\nDynamic programming is typically used for optimization problems. A classic example is the “coin change problem,” which goes as follows:\n“Given a target amount n and a list (array) of distinct coin values, what’s the fewest coins needed to make the change amount?”\nHere is a basic solution in Python:\ndef dpMakeChange(coinValueList, change, minCoins): for cents in range(change + 1): coinCount = cents for j in [c for c in coinValueList if c \u003c= cents]: if minCoins[cents - j] + 1 \u003c coinCount: coinCount = minCoins[cents - j] + 1 minCoins[cents] = coinCount return minCoins[change] print(dpMakeChange([1, 5, 10, 25], 63, [0]*64)) In this code, coinValueList is a list of denominations of coins, change is the amount we want to make change for, and minCoins is a list of the minimum number of coins needed to make change for each value from 0 to change.\nThe function dpMakeChange computes the minimum number of coins needed to make change for all values from 0 to change, and stores these results in minCoins. It then returns the minimum number of coins needed to make change for change.\nWhen dpMakeChange is called with coinValueList = [1, 5, 10, 25], change = 63, and minCoins = [0]*64 (a list of 64 zeroes), it returns 6 because the fewest coins we need to make change for 63 cents with coins of those denominations is 6 (two 25-cent coins, one 10-cent coin, and three 1-cent coins).\n","wordCount":"1885","inLanguage":"en","image":"http://localhost:1313/opengraph.webp","datePublished":"2024-12-24T17:06:45-05:00","dateModified":"2024-12-24T17:06:45-05:00","author":{"@type":"Person","name":"Scott Hong"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/projects/algorithms/"},"publisher":{"@type":"Organization","name":"jtshong","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="jtshong (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>jtshong</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Menu><span>Menu</span></a></li><li><a href=http://localhost:1313/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:1313/arts/ title=Arts><span>Arts</span></a></li><li><a href=https://github.com/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/projects/>Projects</a></div><h1 class="post-title entry-hint-parent">Algorithms</h1><div class=post-meta><span title='2024-12-24 17:06:45 -0500 EST'>2024-12-24</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1885 words&nbsp;·&nbsp;Scott Hong&nbsp;|&nbsp;<a href=https://github.com/DejavuMoe/hugo-start/edit/master/content/posts/projects/algorithms/index.md rel="noopener noreferrer" target=_blank>Edit on GitHub</a></div></header><div class=post-content><h2 id=easy>Easy<a hidden class=anchor aria-hidden=true href=#easy>#</a></h2><h3 id=linear-search>Linear Search<a hidden class=anchor aria-hidden=true href=#linear-search>#</a></h3><p>This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>linear_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></div><h3 id=binary-search>Binary Search<a hidden class=anchor aria-hidden=true href=#binary-search>#</a></h3><p>A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=n>high</span> <span class=o>&gt;=</span> <span class=n>low</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>high</span> <span class=o>+</span> <span class=n>low</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>      <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></div><h3 id=bubble-sort>Bubble Sort<a hidden class=anchor aria-hidden=true href=#bubble-sort>#</a></h3><p>A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>bubble_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span></code></pre></div><h3 id=selection-sort>Selection Sort<a hidden class=anchor aria-hidden=true href=#selection-sort>#</a></h3><p>This sorting algorithm divides the list into a sorted and an unsorted region. It repeatedly selects the smallest (or largest, depending on the ordering) element from the unsorted region and moves it to the sorted region.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>      <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>min_idx</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>      <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=medium>Medium<a hidden class=anchor aria-hidden=true href=#medium>#</a></h2><h3 id=insertion-sort>Insertion Sort<a hidden class=anchor aria-hidden=true href=#insertion-sort>#</a></h3><p>This sorting algorithm builds a sorted list one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insertion_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>key</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&gt;=</span><span class=mi>0</span> <span class=ow>and</span> <span class=n>key</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>key</span>
</span></span></code></pre></div><h3 id=quick-sort>Quick Sort<a hidden class=anchor aria-hidden=true href=#quick-sort>#</a></h3><p>This is a divide-and-conquer sorting algorithm. It works by selecting a &lsquo;pivot&rsquo; element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>pivot</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>low</span> <span class=o>&lt;</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>pi</span> <span class=o>=</span> <span class=n>partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>pi</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>pi</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=merge-sort>Merge Sort<a hidden class=anchor aria-hidden=true href=#merge-sort>#</a></h3><p>Another divide-and-conquer sorting algorithm that involves splitting the array into two halves, sorting them, and then merging them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>//</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=n>L</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>R</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>        <span class=n>merge_sort</span><span class=p>(</span><span class=n>L</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>merge_sort</span><span class=p>(</span><span class=n>R</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>L</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>R</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>L</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>R</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>L</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>L</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>L</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>R</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></div><h3 id=depth-first-search-dfs>Depth-First Search (DFS)<a hidden class=anchor aria-hidden=true href=#depth-first-search-dfs>#</a></h3><p>A common graph traversal algorithm. It explores as far as possible along each branch before backtracking.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>DFS</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>visited</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=s1>&#39; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>v</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=kc>False</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>DFS</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=breadth-first-search-bfs>Breadth-First Search (BFS)<a hidden class=anchor aria-hidden=true href=#breadth-first-search-bfs>#</a></h3><p>Another common graph traversal algorithm. It visits all the vertices of a graph at the same &ldquo;level&rdquo; before going to the next level.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>BFS</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>root</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>vertex</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbour</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>vertex</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbour</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>neighbour</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>neighbour</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=hard>Hard<a hidden class=anchor aria-hidden=true href=#hard>#</a></h2><h3 id=heap-sort>Heap Sort<a hidden class=anchor aria-hidden=true href=#heap-sort>#</a></h3><p>This comparison-based sorting algorithm transforms the input data structure into a binary heap data structure. It then uses the heap pop operation to obtain the elements in sorted order.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>largest</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>l</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>l</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>l</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>r</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>r</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>largest</span> <span class=o>!=</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>],</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>largest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>heapSort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>//</span><span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=dijkstras-algorithm>Dijkstra&rsquo;s Algorithm<a hidden class=anchor aria-hidden=true href=#dijkstras-algorithm>#</a></h3><p>This algorithm is used to find the shortest path between nodes in a graph. It works for both directed and undirected graphs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>D</span> <span class=o>=</span> <span class=p>{</span><span class=n>v</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>D</span><span class=p>[</span><span class=n>start_vertex</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>d</span><span class=p>,</span> <span class=n>v</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>d</span> <span class=o>!=</span> <span class=n>D</span><span class=p>[</span><span class=n>v</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbour</span><span class=p>,</span> <span class=n>length</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>old_distance</span> <span class=o>=</span> <span class=n>D</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>new_distance</span> <span class=o>=</span> <span class=n>D</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>+</span> <span class=n>length</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>new_distance</span> <span class=o>&lt;</span> <span class=n>old_distance</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>D</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>new_distance</span>
</span></span><span class=line><span class=cl>                <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=p>(</span><span class=n>new_distance</span><span class=p>,</span> <span class=n>neighbour</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>D</span>
</span></span></code></pre></div><h3 id=bellman-ford-algorithm>Bellman-Ford Algorithm<a hidden class=anchor aria-hidden=true href=#bellman-ford-algorithm>#</a></h3><p>This algorithm computes shortest paths in a weighted graph where some of the edge weights may be negative.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>bellman_ford</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>,</span> <span class=n>predecessor</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>(),</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>],</span> <span class=n>predecessor</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>),</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>[</span><span class=n>start_vertex</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>neighbour</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>distance</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>+</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>distance</span><span class=p>[</span><span class=n>neighbour</span><span class=p>],</span> <span class=n>predecessor</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>+</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>],</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distance</span><span class=p>,</span> <span class=n>predecessor</span>
</span></span></code></pre></div><h3 id=floyd-warshall-algorithm>Floyd-Warshall Algorithm<a hidden class=anchor aria-hidden=true href=#floyd-warshall-algorithm>#</a></h3><p>This is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>floyd_warshall</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbour</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>intermediate_node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>start_node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>end_node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>direct</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>start_node</span><span class=p>][</span><span class=n>end_node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>via_i</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>start_node</span><span class=p>][</span><span class=n>intermediate_node</span><span class=p>]</span> <span class=o>+</span> <span class=n>distance</span><span class=p>[</span><span class=n>intermediate_node</span><span class=p>][</span><span class=n>end_node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>direct</span> <span class=o>&gt;</span> <span class=n>via_i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>distance</span><span class=p>[</span><span class=n>start_node</span><span class=p>][</span><span class=n>end_node</span><span class=p>]</span> <span class=o>=</span> <span class=n>via_i</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distance</span>
</span></span></code></pre></div><h3 id=binary-search-tree>Binary Search Tree<a hidden class=anchor aria-hidden=true href=#binary-search-tree>#</a></h3><p>A Binary Search Tree (BST) is a tree in which all the nodes follow the below property: the left sub-tree of a node has a key less than its parent node&rsquo;s key, while the right sub-tree of a node has a key greater than to its parent node&rsquo;s key.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>val</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Node</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>root</span><span class=o>.</span><span class=n>val</span> <span class=o>&lt;</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>val</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=knapsack-problem-algorithms>Knapsack Problem Algorithms<a hidden class=anchor aria-hidden=true href=#knapsack-problem-algorithms>#</a></h3><p>The knapsack problem is an optimization problem used to illustrate both problem-solving and computational complexity. There are various algorithms to solve it, including brute force, greedy, and dynamic programming.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapSack</span><span class=p>(</span><span class=n>W</span><span class=p>,</span> <span class=n>wt</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>K</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>W</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>W</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>w</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>wt</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>val</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>wt</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]],</span> <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>K</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>W</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test the function with a problem instance</span>
</span></span><span class=line><span class=cl><span class=n>val</span> <span class=o>=</span> <span class=p>[</span><span class=mi>60</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>120</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>wt</span> <span class=o>=</span> <span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>W</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>knapSack</span><span class=p>(</span><span class=n>W</span><span class=p>,</span> <span class=n>wt</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>n</span><span class=p>))</span>  <span class=c1># Outputs 220</span>
</span></span></code></pre></div><p>In this example, W is the maximum weight the knapsack can hold, wt is the list of weights of the items, val is the list of values of the items, and n is the number of items.</p><p>This function works by building up a 2D array K[][] where each element K[i][w] stores the maximum value that can be achieved with i items and a maximum weight of w. For each item, it considers if it&rsquo;s optimal to include the item or not by comparing the maximum value achieved by including the item (val[i-1] + K[i-1][w-wt[i-1]]) and the maximum value achieved by excluding the item (K[i-1][w]), and takes the maximum of these two values.</p><h3 id=travelling-salesman-problem-algorithms>Travelling Salesman Problem Algorithms<a hidden class=anchor aria-hidden=true href=#travelling-salesman-problem-algorithms>#</a></h3><p>The travelling salesman problem is a classic algorithmic problem focused on optimization. It focuses on optimization. In this problem, a salesman is given a list of cities, and must determine the shortest route that allows him to visit each city once and return to his original location.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sys</span> <span class=kn>import</span> <span class=n>maxsize</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>permutations</span>
</span></span><span class=line><span class=cl><span class=n>V</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>travellingSalesmanProblem</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>vertex</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>s</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>vertex</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>min_path</span> <span class=o>=</span> <span class=n>maxsize</span>
</span></span><span class=line><span class=cl>    <span class=n>next_permutation</span><span class=o>=</span><span class=n>permutations</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>next_permutation</span><span class=p>:</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>current_pathweight</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current_pathweight</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>        <span class=n>current_pathweight</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>s</span><span class=p>]</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>min_path</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_path</span><span class=p>,</span> <span class=n>current_pathweight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>min_path</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>20</span><span class=p>],</span> <span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>35</span><span class=p>,</span> <span class=mi>25</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=mi>15</span><span class=p>,</span> <span class=mi>35</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>30</span><span class=p>],</span> <span class=p>[</span><span class=mi>20</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>travellingSalesmanProblem</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>s</span><span class=p>))</span>
</span></span></code></pre></div><p>In this code, s is the starting point, and graph[i][j] is the length of the path from i to j. This code iterates over all permutations of the vertices (excluding the starting vertex s) to find the minimum weight cycle.</p><p>Please note that this code has a time complexity of O(n!), where n is the number of vertices, because it tries all possible permutations. Therefore, it can be very slow for larger graphs. There are more efficient algorithms to solve the TSP for special cases (like when the graph satisfies the triangle inequality), and there are also approximation algorithms for the general case.</p><h2 id=dynamic-programing>Dynamic Programing<a hidden class=anchor aria-hidden=true href=#dynamic-programing>#</a></h2><p>Dynamic programming (DP) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions - ideally, using a memory-based data structure.</p><p>The idea is to save computation time by avoiding needless recomputation of identical subproblems - this is also known as &ldquo;memoization&rdquo;. The technique was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.</p><p>The key concept here is the &ldquo;principle of optimality,&rdquo; which is the idea that the optimal solution to a problem can be constructed from the optimal solutions of its subproblems.</p><p>Dynamic programming is typically used for optimization problems. A classic example is the &ldquo;coin change problem,&rdquo; which goes as follows:</p><p>&ldquo;Given a target amount n and a list (array) of distinct coin values, what&rsquo;s the fewest coins needed to make the change amount?&rdquo;</p><p>Here is a basic solution in Python:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dpMakeChange</span><span class=p>(</span><span class=n>coinValueList</span><span class=p>,</span> <span class=n>change</span><span class=p>,</span> <span class=n>minCoins</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>cents</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>change</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>coinCount</span> <span class=o>=</span> <span class=n>cents</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=p>[</span><span class=n>c</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>coinValueList</span> <span class=k>if</span> <span class=n>c</span> <span class=o>&lt;=</span> <span class=n>cents</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>minCoins</span><span class=p>[</span><span class=n>cents</span> <span class=o>-</span> <span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>coinCount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>coinCount</span> <span class=o>=</span> <span class=n>minCoins</span><span class=p>[</span><span class=n>cents</span> <span class=o>-</span> <span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>minCoins</span><span class=p>[</span><span class=n>cents</span><span class=p>]</span> <span class=o>=</span> <span class=n>coinCount</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>minCoins</span><span class=p>[</span><span class=n>change</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>dpMakeChange</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>25</span><span class=p>],</span> <span class=mi>63</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=mi>64</span><span class=p>))</span>
</span></span></code></pre></div><p>In this code, coinValueList is a list of denominations of coins, change is the amount we want to make change for, and minCoins is a list of the minimum number of coins needed to make change for each value from 0 to change.</p><p>The function dpMakeChange computes the minimum number of coins needed to make change for all values from 0 to change, and stores these results in minCoins. It then returns the minimum number of coins needed to make change for change.</p><p>When dpMakeChange is called with coinValueList = [1, 5, 10, 25], change = 63, and minCoins = [0]*64 (a list of 64 zeroes), it returns 6 because the fewest coins we need to make change for 63 cents with coins of those denominations is 6 (two 25-cent coins, one 10-cent coin, and three 1-cent coins).</p></div><footer class=post-footer><ul class=post-tags></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms on x" href="https://x.com/intent/tweet/?text=Algorithms&amp;url=http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f&amp;title=Algorithms&amp;summary=Algorithms&amp;source=http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f&title=Algorithms"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms on whatsapp" href="https://api.whatsapp.com/send?text=Algorithms%20-%20http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms on telegram" href="https://telegram.me/share/url?text=Algorithms&amp;url=http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Algorithms on ycombinator" href="https://news.ycombinator.com/submitlink?t=Algorithms&u=http%3a%2f%2flocalhost%3a1313%2fprojects%2falgorithms%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>jtshong</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>