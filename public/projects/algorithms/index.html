<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithms | jtshong</title>
<meta name=keywords content><meta name=description content="Easy
Linear Search
This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.
def linear_search(arr, x):
   for i in range(len(arr)):
      if arr[i] == x:
         return i
   return -1
Binary Search
A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space."><meta name=author content="Scott Hong"><link rel=canonical href=http://localhost:1313/projects/algorithms/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon.ico><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/projects/algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/projects/algorithms/"><meta property="og:site_name" content="jtshong"><meta property="og:title" content="Algorithms"><meta property="og:description" content="Easy Linear Search This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.
def linear_search(arr, x): for i in range(len(arr)): if arr[i] == x: return i return -1 Binary Search A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2024-12-24T17:06:45-05:00"><meta property="article:modified_time" content="2024-12-24T17:06:45-05:00"><meta property="og:image" content="http://localhost:1313/algorithms.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/algorithms.jpg"><meta name=twitter:title content="Algorithms"><meta name=twitter:description content="Easy
Linear Search
This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.
def linear_search(arr, x):
   for i in range(len(arr)):
      if arr[i] == x:
         return i
   return -1
Binary Search
A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"http://localhost:1313/projects/"},{"@type":"ListItem","position":2,"name":"Algorithms","item":"http://localhost:1313/projects/algorithms/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Algorithms","name":"Algorithms","description":"Easy Linear Search This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.\ndef linear_search(arr, x): for i in range(len(arr)): if arr[i] == x: return i return -1 Binary Search A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space.\n","keywords":[],"articleBody":"Easy Linear Search This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.\ndef linear_search(arr, x): for i in range(len(arr)): if arr[i] == x: return i return -1 Binary Search A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space.\ndef binary_search(arr, low, high, x): if high \u003e= low: mid = (high + low) // 2 if arr[mid] == x: return mid elif arr[mid] \u003e x: return binary_search(arr, low, mid - 1, x) else: return binary_search(arr, mid + 1, high, x) else: return -1 Bubble Sort A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.\ndef bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n - i - 1): if arr[j] \u003e arr[j + 1] : arr[j], arr[j + 1] = arr[j + 1], arr[j] Selection Sort This sorting algorithm divides the list into a sorted and an unsorted region. It repeatedly selects the smallest (or largest, depending on the ordering) element from the unsorted region and moves it to the sorted region.\ndef selection_sort(arr): for i in range(len(arr)): min_idx = i for j in range(i+1, len(arr)): if arr[min_idx] \u003e arr[j]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i] Medium Insertion Sort This sorting algorithm builds a sorted list one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.\ndef insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i-1 while j \u003e=0 and key \u003c arr[j] : arr[j+1] = arr[j] j -= 1 arr[j+1] = key Quick Sort This is a divide-and-conquer sorting algorithm. It works by selecting a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.\ndef partition(arr, low, high): i = (low-1) pivot = arr[high] for j in range(low, high): if arr[j] \u003c= pivot: i = i+1 arr[i], arr[j] = arr[j], arr[i] arr[i+1], arr[high] = arr[high], arr[i+1] return (i+1) def quick_sort(arr, low, high): if len(arr) == 1: return arr if low \u003c high: pi = partition(arr, low, high) quick_sort(arr, low, pi-1) quick_sort(arr, pi+1, high) Merge Sort Another divide-and-conquer sorting algorithm that involves splitting the array into two halves, sorting them, and then merging them.\ndef merge_sort(arr): if len(arr) \u003e 1: mid = len(arr)//2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i \u003c len(L) and j \u003c len(R): if L[i] \u003c R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i \u003c len(L): arr[k] = L[i] i += 1 k += 1 while j \u003c len(R): arr[k] = R[j] j += 1 k += 1 Depth-First Search (DFS) A common graph traversal algorithm. It explores as far as possible along each branch before backtracking.\ndef DFS(graph, v, visited): visited[v] = True print(v, end = ' ') for i in graph[v]: if visited[i] == False: DFS(graph, i, visited) Breadth-First Search (BFS) Another common graph traversal algorithm. It visits all the vertices of a graph at the same “level” before going to the next level.\nfrom collections import deque def BFS(graph, root): visited = set() queue = deque([root]) visited.add(root) while queue: vertex = queue.popleft() print(str(vertex) + \" \", end=\"\") for neighbour in graph[vertex]: if neighbour not in visited: queue.append(neighbour) visited.add(neighbour) Hard Heap Sort This comparison-based sorting algorithm transforms the input data structure into a binary heap data structure. It then uses the heap pop operation to obtain the elements in sorted order.\ndef heapify(arr, n, i): largest = i l = 2 * i + 1 r = 2 * i + 2 if l \u003c n and arr[i] \u003c arr[l]: largest = l if r \u003c n and arr[largest] \u003c arr[r]: largest = r if largest != i: arr[i],arr[largest] = arr[largest],arr[i] heapify(arr, n, largest) def heapSort(arr): n = len(arr) for i in range(n//2 - 1, -1, -1): heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) Dijkstra’s Algorithm This algorithm is used to find the shortest path between nodes in a graph. It works for both directed and undirected graphs.\nimport heapq def dijkstra(graph, start_vertex): D = {v: float('inf') for v in graph} D[start_vertex] = 0 queue = [(0, start_vertex)] while queue: d, v = heapq.heappop(queue) if d != D[v]: continue for neighbour, length in graph[v].items(): old_distance = D[neighbour] new_distance = D[v] + length if new_distance \u003c old_distance: D[neighbour] = new_distance heapq.heappush(queue, (new_distance, neighbour)) return D Bellman-Ford Algorithm This algorithm computes shortest paths in a weighted graph where some of the edge weights may be negative.\ndef bellman_ford(graph, start_vertex): distance, predecessor = dict(), dict() for node in graph: distance[node], predecessor[node] = float('inf'), None distance[start_vertex] = 0 for _ in range(len(graph) - 1): for node in graph: for neighbour in graph[node]: if distance[neighbour] \u003e distance[node] + graph[node][neighbour]: distance[neighbour], predecessor[neighbour] = distance[node] + graph[node][neighbour], node return distance, predecessor Floyd-Warshall Algorithm This is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.\ndef floyd_warshall(graph): distance = dict() for node in graph: distance[node] = dict() for neighbour in graph: distance[node][neighbour] = graph[node][neighbour] for intermediate_node in graph: for start_node in graph: for end_node in graph: direct = distance[start_node][end_node] via_i = distance[start_node][intermediate_node] + distance[intermediate_node][end_node] if direct \u003e via_i: distance[start_node][end_node] = via_i return distance Binary Search Tree A Binary Search Tree (BST) is a tree in which all the nodes follow the below property: the left sub-tree of a node has a key less than its parent node’s key, while the right sub-tree of a node has a key greater than to its parent node’s key.\nclass Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return Node(key) else: if root.val \u003c key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def inorder(root): if root: inorder(root.left) print(root.val), inorder(root.right) Knapsack Problem Algorithms The knapsack problem is an optimization problem used to illustrate both problem-solving and computational complexity. There are various algorithms to solve it, including brute force, greedy, and dynamic programming.\ndef knapSack(W, wt, val, n): K = [[0 for w in range(W+1)] for i in range(n+1)] for i in range(n+1): for w in range(W+1): if i == 0 or w == 0: K[i][w] = 0 elif wt[i-1] \u003c= w: K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]) else: K[i][w] = K[i-1][w] return K[n][W] # Test the function with a problem instance val = [60, 100, 120] wt = [10, 20, 30] W = 50 n = len(val) print(knapSack(W, wt, val, n)) # Outputs 220 In this example, W is the maximum weight the knapsack can hold, wt is the list of weights of the items, val is the list of values of the items, and n is the number of items.\nThis function works by building up a 2D array K[][] where each element K[i][w] stores the maximum value that can be achieved with i items and a maximum weight of w. For each item, it considers if it’s optimal to include the item or not by comparing the maximum value achieved by including the item (val[i-1] + K[i-1][w-wt[i-1]]) and the maximum value achieved by excluding the item (K[i-1][w]), and takes the maximum of these two values.\nTravelling Salesman Problem Algorithms The travelling salesman problem is a classic algorithmic problem focused on optimization. It focuses on optimization. In this problem, a salesman is given a list of cities, and must determine the shortest route that allows him to visit each city once and return to his original location.\nfrom sys import maxsize from itertools import permutations V = 4 def travellingSalesmanProblem(graph, s): vertex = [] for i in range(V): if i != s: vertex.append(i) min_path = maxsize next_permutation=permutations(vertex) for i in next_permutation: current_pathweight = 0 k = s for j in i: current_pathweight += graph[k][j] k = j current_pathweight += graph[k][s] min_path = min(min_path, current_pathweight) return min_path if __name__ == \"__main__\": graph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]] s = 0 print(travellingSalesmanProblem(graph, s)) In this code, s is the starting point, and graph[i][j] is the length of the path from i to j. This code iterates over all permutations of the vertices (excluding the starting vertex s) to find the minimum weight cycle.\nPlease note that this code has a time complexity of O(n!), where n is the number of vertices, because it tries all possible permutations. Therefore, it can be very slow for larger graphs. There are more efficient algorithms to solve the TSP for special cases (like when the graph satisfies the triangle inequality), and there are also approximation algorithms for the general case.\nDynamic Programing Dynamic programming (DP) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions - ideally, using a memory-based data structure.\nThe idea is to save computation time by avoiding needless recomputation of identical subproblems - this is also known as “memoization”. The technique was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.\nThe key concept here is the “principle of optimality,” which is the idea that the optimal solution to a problem can be constructed from the optimal solutions of its subproblems.\nDynamic programming is typically used for optimization problems. A classic example is the “coin change problem,” which goes as follows:\n“Given a target amount n and a list (array) of distinct coin values, what’s the fewest coins needed to make the change amount?”\nHere is a basic solution in Python:\ndef dpMakeChange(coinValueList, change, minCoins): for cents in range(change + 1): coinCount = cents for j in [c for c in coinValueList if c \u003c= cents]: if minCoins[cents - j] + 1 \u003c coinCount: coinCount = minCoins[cents - j] + 1 minCoins[cents] = coinCount return minCoins[change] print(dpMakeChange([1, 5, 10, 25], 63, [0]*64)) In this code, coinValueList is a list of denominations of coins, change is the amount we want to make change for, and minCoins is a list of the minimum number of coins needed to make change for each value from 0 to change.\nThe function dpMakeChange computes the minimum number of coins needed to make change for all values from 0 to change, and stores these results in minCoins. It then returns the minimum number of coins needed to make change for change.\nWhen dpMakeChange is called with coinValueList = [1, 5, 10, 25], change = 63, and minCoins = [0]*64 (a list of 64 zeroes), it returns 6 because the fewest coins we need to make change for 63 cents with coins of those denominations is 6 (two 25-cent coins, one 10-cent coin, and three 1-cent coins).\n","wordCount":"1885","inLanguage":"en","image":"http://localhost:1313/algorithms.jpg","datePublished":"2024-12-24T17:06:45-05:00","dateModified":"2024-12-24T17:06:45-05:00","author":{"@type":"Person","name":"Scott Hong"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/projects/algorithms/"},"publisher":{"@type":"Organization","name":"jtshong","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="jtshong (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>jtshong</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Menu><span>Menu</span></a></li><li><a href=http://localhost:1313/projects/ title=Projects><span>Projects</span></a></li><li><a href=http://localhost:1313/arts/ title=Arts><span>Arts</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=https://github.com/jts-hong title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/projects/>Projects</a></div><h1 class="post-title entry-hint-parent">Algorithms</h1><div class=post-meta><span title='2024-12-24 17:06:45 -0500 EST'>2024-12-24</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1885 words&nbsp;·&nbsp;Scott Hong</div></header><figure class=entry-cover><img loading=eager srcset="http://localhost:1313/projects/algorithms/algorithms_hu1082654525722877623.jpg 360w ,http://localhost:1313/projects/algorithms/algorithms_hu6340354262145013176.jpg 480w ,http://localhost:1313/projects/algorithms/algorithms_hu8921568252108928206.jpg 720w ,http://localhost:1313/projects/algorithms/algorithms_hu1340409881049954827.jpg 1080w ,http://localhost:1313/projects/algorithms/algorithms.jpg 1280w" sizes="(min-width: 768px) 720px, 100vw" src=http://localhost:1313/projects/algorithms/algorithms.jpg alt=algorithms width=1280 height=720></figure><div class=post-content><h2 id=easy>Easy<a hidden class=anchor aria-hidden=true href=#easy>#</a></h2><h3 id=linear-search>Linear Search<a hidden class=anchor aria-hidden=true href=#linear-search>#</a></h3><p>This is the simplest searching algorithm. It sequentially checks each element of the list until a match is found or the whole list has been searched.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>linear_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></div><h3 id=binary-search>Binary Search<a hidden class=anchor aria-hidden=true href=#binary-search>#</a></h3><p>A more efficient searching algorithm than linear search, but it requires the list to be sorted. It starts by checking the middle element of a list and divides the search space in half at each step until it finds the target element or exhausts the search space.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=n>high</span> <span class=o>&gt;=</span> <span class=n>low</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>high</span> <span class=o>+</span> <span class=n>low</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>      <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></div><h3 id=bubble-sort>Bubble Sort<a hidden class=anchor aria-hidden=true href=#bubble-sort>#</a></h3><p>A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>bubble_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span></code></pre></div><h3 id=selection-sort>Selection Sort<a hidden class=anchor aria-hidden=true href=#selection-sort>#</a></h3><p>This sorting algorithm divides the list into a sorted and an unsorted region. It repeatedly selects the smallest (or largest, depending on the ordering) element from the unsorted region and moves it to the sorted region.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>      <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>min_idx</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>      <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=medium>Medium<a hidden class=anchor aria-hidden=true href=#medium>#</a></h2><h3 id=insertion-sort>Insertion Sort<a hidden class=anchor aria-hidden=true href=#insertion-sort>#</a></h3><p>This sorting algorithm builds a sorted list one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insertion_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>key</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&gt;=</span><span class=mi>0</span> <span class=ow>and</span> <span class=n>key</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>key</span>
</span></span></code></pre></div><h3 id=quick-sort>Quick Sort<a hidden class=anchor aria-hidden=true href=#quick-sort>#</a></h3><p>This is a divide-and-conquer sorting algorithm. It works by selecting a &lsquo;pivot&rsquo; element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>pivot</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>low</span> <span class=o>&lt;</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>pi</span> <span class=o>=</span> <span class=n>partition</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>pi</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>pi</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=merge-sort>Merge Sort<a hidden class=anchor aria-hidden=true href=#merge-sort>#</a></h3><p>Another divide-and-conquer sorting algorithm that involves splitting the array into two halves, sorting them, and then merging them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span><span class=o>//</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=n>L</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>R</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>        <span class=n>merge_sort</span><span class=p>(</span><span class=n>L</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>merge_sort</span><span class=p>(</span><span class=n>R</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>L</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>R</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>L</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>R</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>L</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>L</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>L</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>R</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>R</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></div><h3 id=depth-first-search-dfs>Depth-First Search (DFS)<a hidden class=anchor aria-hidden=true href=#depth-first-search-dfs>#</a></h3><p>A common graph traversal algorithm. It explores as far as possible along each branch before backtracking.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>DFS</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>visited</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=s1>&#39; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>v</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=kc>False</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>DFS</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=breadth-first-search-bfs>Breadth-First Search (BFS)<a hidden class=anchor aria-hidden=true href=#breadth-first-search-bfs>#</a></h3><p>Another common graph traversal algorithm. It visits all the vertices of a graph at the same &ldquo;level&rdquo; before going to the next level.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>BFS</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>root</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>vertex</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34; &#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbour</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>vertex</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbour</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>neighbour</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>neighbour</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=hard>Hard<a hidden class=anchor aria-hidden=true href=#hard>#</a></h2><h3 id=heap-sort>Heap Sort<a hidden class=anchor aria-hidden=true href=#heap-sort>#</a></h3><p>This comparison-based sorting algorithm transforms the input data structure into a binary heap data structure. It then uses the heap pop operation to obtain the elements in sorted order.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>largest</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>l</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>l</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>l</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>r</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>r</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>r</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>largest</span> <span class=o>!=</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>],</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>largest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>heapSort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>//</span><span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=dijkstras-algorithm>Dijkstra&rsquo;s Algorithm<a hidden class=anchor aria-hidden=true href=#dijkstras-algorithm>#</a></h3><p>This algorithm is used to find the shortest path between nodes in a graph. It works for both directed and undirected graphs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>D</span> <span class=o>=</span> <span class=p>{</span><span class=n>v</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>D</span><span class=p>[</span><span class=n>start_vertex</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>d</span><span class=p>,</span> <span class=n>v</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>d</span> <span class=o>!=</span> <span class=n>D</span><span class=p>[</span><span class=n>v</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbour</span><span class=p>,</span> <span class=n>length</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>old_distance</span> <span class=o>=</span> <span class=n>D</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>new_distance</span> <span class=o>=</span> <span class=n>D</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>+</span> <span class=n>length</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>new_distance</span> <span class=o>&lt;</span> <span class=n>old_distance</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>D</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>new_distance</span>
</span></span><span class=line><span class=cl>                <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>queue</span><span class=p>,</span> <span class=p>(</span><span class=n>new_distance</span><span class=p>,</span> <span class=n>neighbour</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>D</span>
</span></span></code></pre></div><h3 id=bellman-ford-algorithm>Bellman-Ford Algorithm<a hidden class=anchor aria-hidden=true href=#bellman-ford-algorithm>#</a></h3><p>This algorithm computes shortest paths in a weighted graph where some of the edge weights may be negative.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>bellman_ford</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>,</span> <span class=n>predecessor</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>(),</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>],</span> <span class=n>predecessor</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>),</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span><span class=p>[</span><span class=n>start_vertex</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>neighbour</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>distance</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>+</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>distance</span><span class=p>[</span><span class=n>neighbour</span><span class=p>],</span> <span class=n>predecessor</span><span class=p>[</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>+</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>],</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distance</span><span class=p>,</span> <span class=n>predecessor</span>
</span></span></code></pre></div><h3 id=floyd-warshall-algorithm>Floyd-Warshall Algorithm<a hidden class=anchor aria-hidden=true href=#floyd-warshall-algorithm>#</a></h3><p>This is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>floyd_warshall</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbour</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>distance</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>]</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>][</span><span class=n>neighbour</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>intermediate_node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>start_node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>end_node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>direct</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>start_node</span><span class=p>][</span><span class=n>end_node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>via_i</span> <span class=o>=</span> <span class=n>distance</span><span class=p>[</span><span class=n>start_node</span><span class=p>][</span><span class=n>intermediate_node</span><span class=p>]</span> <span class=o>+</span> <span class=n>distance</span><span class=p>[</span><span class=n>intermediate_node</span><span class=p>][</span><span class=n>end_node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>direct</span> <span class=o>&gt;</span> <span class=n>via_i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>distance</span><span class=p>[</span><span class=n>start_node</span><span class=p>][</span><span class=n>end_node</span><span class=p>]</span> <span class=o>=</span> <span class=n>via_i</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distance</span>
</span></span></code></pre></div><h3 id=binary-search-tree>Binary Search Tree<a hidden class=anchor aria-hidden=true href=#binary-search-tree>#</a></h3><p>A Binary Search Tree (BST) is a tree in which all the nodes follow the below property: the left sub-tree of a node has a key less than its parent node&rsquo;s key, while the right sub-tree of a node has a key greater than to its parent node&rsquo;s key.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>val</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>Node</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>root</span><span class=o>.</span><span class=n>val</span> <span class=o>&lt;</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>insert</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>val</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=knapsack-problem-algorithms>Knapsack Problem Algorithms<a hidden class=anchor aria-hidden=true href=#knapsack-problem-algorithms>#</a></h3><p>The knapsack problem is an optimization problem used to illustrate both problem-solving and computational complexity. There are various algorithms to solve it, including brute force, greedy, and dynamic programming.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapSack</span><span class=p>(</span><span class=n>W</span><span class=p>,</span> <span class=n>wt</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>K</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>W</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>W</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>w</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>wt</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>val</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>wt</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]],</span> <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>K</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>K</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>W</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test the function with a problem instance</span>
</span></span><span class=line><span class=cl><span class=n>val</span> <span class=o>=</span> <span class=p>[</span><span class=mi>60</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>120</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>wt</span> <span class=o>=</span> <span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>W</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>knapSack</span><span class=p>(</span><span class=n>W</span><span class=p>,</span> <span class=n>wt</span><span class=p>,</span> <span class=n>val</span><span class=p>,</span> <span class=n>n</span><span class=p>))</span>  <span class=c1># Outputs 220</span>
</span></span></code></pre></div><p>In this example, W is the maximum weight the knapsack can hold, wt is the list of weights of the items, val is the list of values of the items, and n is the number of items.</p><p>This function works by building up a 2D array K[][] where each element K[i][w] stores the maximum value that can be achieved with i items and a maximum weight of w. For each item, it considers if it&rsquo;s optimal to include the item or not by comparing the maximum value achieved by including the item (val[i-1] + K[i-1][w-wt[i-1]]) and the maximum value achieved by excluding the item (K[i-1][w]), and takes the maximum of these two values.</p><h3 id=travelling-salesman-problem-algorithms>Travelling Salesman Problem Algorithms<a hidden class=anchor aria-hidden=true href=#travelling-salesman-problem-algorithms>#</a></h3><p>The travelling salesman problem is a classic algorithmic problem focused on optimization. It focuses on optimization. In this problem, a salesman is given a list of cities, and must determine the shortest route that allows him to visit each city once and return to his original location.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sys</span> <span class=kn>import</span> <span class=n>maxsize</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>permutations</span>
</span></span><span class=line><span class=cl><span class=n>V</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>travellingSalesmanProblem</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>vertex</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>s</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>vertex</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>min_path</span> <span class=o>=</span> <span class=n>maxsize</span>
</span></span><span class=line><span class=cl>    <span class=n>next_permutation</span><span class=o>=</span><span class=n>permutations</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>next_permutation</span><span class=p>:</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>current_pathweight</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current_pathweight</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>        <span class=n>current_pathweight</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>s</span><span class=p>]</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=n>min_path</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_path</span><span class=p>,</span> <span class=n>current_pathweight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>min_path</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>15</span><span class=p>,</span> <span class=mi>20</span><span class=p>],</span> <span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>35</span><span class=p>,</span> <span class=mi>25</span><span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=p>[</span><span class=mi>15</span><span class=p>,</span> <span class=mi>35</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>30</span><span class=p>],</span> <span class=p>[</span><span class=mi>20</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>travellingSalesmanProblem</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>s</span><span class=p>))</span>
</span></span></code></pre></div><p>In this code, s is the starting point, and graph[i][j] is the length of the path from i to j. This code iterates over all permutations of the vertices (excluding the starting vertex s) to find the minimum weight cycle.</p><p>Please note that this code has a time complexity of O(n!), where n is the number of vertices, because it tries all possible permutations. Therefore, it can be very slow for larger graphs. There are more efficient algorithms to solve the TSP for special cases (like when the graph satisfies the triangle inequality), and there are also approximation algorithms for the general case.</p><h2 id=dynamic-programing>Dynamic Programing<a hidden class=anchor aria-hidden=true href=#dynamic-programing>#</a></h2><p>Dynamic programming (DP) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions - ideally, using a memory-based data structure.</p><p>The idea is to save computation time by avoiding needless recomputation of identical subproblems - this is also known as &ldquo;memoization&rdquo;. The technique was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.</p><p>The key concept here is the &ldquo;principle of optimality,&rdquo; which is the idea that the optimal solution to a problem can be constructed from the optimal solutions of its subproblems.</p><p>Dynamic programming is typically used for optimization problems. A classic example is the &ldquo;coin change problem,&rdquo; which goes as follows:</p><p>&ldquo;Given a target amount n and a list (array) of distinct coin values, what&rsquo;s the fewest coins needed to make the change amount?&rdquo;</p><p>Here is a basic solution in Python:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Python data-lang=Python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dpMakeChange</span><span class=p>(</span><span class=n>coinValueList</span><span class=p>,</span> <span class=n>change</span><span class=p>,</span> <span class=n>minCoins</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>cents</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>change</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>coinCount</span> <span class=o>=</span> <span class=n>cents</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=p>[</span><span class=n>c</span> <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>coinValueList</span> <span class=k>if</span> <span class=n>c</span> <span class=o>&lt;=</span> <span class=n>cents</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>minCoins</span><span class=p>[</span><span class=n>cents</span> <span class=o>-</span> <span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>coinCount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>coinCount</span> <span class=o>=</span> <span class=n>minCoins</span><span class=p>[</span><span class=n>cents</span> <span class=o>-</span> <span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>minCoins</span><span class=p>[</span><span class=n>cents</span><span class=p>]</span> <span class=o>=</span> <span class=n>coinCount</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>minCoins</span><span class=p>[</span><span class=n>change</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>dpMakeChange</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>25</span><span class=p>],</span> <span class=mi>63</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=mi>64</span><span class=p>))</span>
</span></span></code></pre></div><p>In this code, coinValueList is a list of denominations of coins, change is the amount we want to make change for, and minCoins is a list of the minimum number of coins needed to make change for each value from 0 to change.</p><p>The function dpMakeChange computes the minimum number of coins needed to make change for all values from 0 to change, and stores these results in minCoins. It then returns the minimum number of coins needed to make change for change.</p><p>When dpMakeChange is called with coinValueList = [1, 5, 10, 25], change = 63, and minCoins = [0]*64 (a list of 64 zeroes), it returns 6 because the fewest coins we need to make change for 63 cents with coins of those denominations is 6 (two 25-cent coins, one 10-cent coin, and three 1-cent coins).</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>jtshong</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>